{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bacherlor of Electronic and Electrical Engineering (BEEE Notes)","text":"<p>By Joshua Oh</p> <p>This repository serves as a personal documentation of my notes, learnings, and experiments in my 4 years Engineering course. It covers key concepts, algorithms, and practical implementations in all subjects of both the electronic and electrical fields.</p> <p>Feel free to explore, learn, and contribute!</p> <p>Bug</p> <p>Since I wrote everything here myself with some help from AI, there may be some mistakes made. If you seen any mistakes, please email them to:  <pre><code>yuqiao.oh@gmail.com\n</code></pre></p>"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart1/","title":"Fourier Series: Part 1","text":""},{"location":"ENG2053%20Engineering%20Math%203/FourierPart1/#introduction","title":"Introduction","text":"<ul> <li> <p>Fourier series is a mathematical tool to breakdown complex pattern into simpler parts.</p> </li> <li> <p>By using Fourier series, we can represent any periodic function as a sum of sine and cosine functions with different frequencies.</p> </li> </ul> <p>Example</p> <p>Using Fourier series, a song can be represented by adding up different \"notes\", each with their own frequency. </p> <p>Extra Info</p> <p>Fourier series is used in many fields:</p> <ul> <li>Signal Processing :  Used to analyze and clean up signals (eg. In MP3 audio files, it helps remove unnecessary data but keeps the sound quality). </li> <li>Engineering : Helps design and analyze circuits with AC (alternating current) and useful in image processing to break down image details by frequency.</li> <li>Physics: Explains wave behavior, vibrations, and oscillations (sound (acoustics), light (optics), and even quantum mechanics).</li> </ul> <ul> <li>In simple words, Fourier series helps simplify complex patterns into simpler components, which makes the signals easier to analyze and manipulate.</li> </ul>"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart1/#basic-theory-of-fourier-series","title":"Basic Theory of Fourier Series","text":"<ul> <li>Periodic function \\(f(X)\\) with period \\(L\\) show the same pattern every \\(L\\) units along the x-axis, hence \\(f(x+L) = f(x)\\) for every value of \\(x\\) . </li> </ul> <ul> <li> <p>If we know what the function looks like over one complete period, we can sketch a graph of the function over a wider interval of x (many periods).</p> </li> <li> <p>Property of repetition defines the fundamental spatial frequency,  </p> </li> </ul> <p>\\(k = \\frac{2\\pi}{L}\\), that is used to give the first approximation to the periodic pattern \\(f(x)\\):</p> <p>$$   f(x) \\approx C_1 \\sin(kx + \\alpha_1) = a_1 \\cos(kx) + b_1 \\sin(kx)   $$</p> <p>where \\(a_1\\), \\(b_1\\), and \\(C_1\\) are constants of amplitudes, and \\(\\alpha_1\\) is a constant of phase for the first approximation.</p> <ul> <li>A much better approximation can be built by adding an appropriate combination of harmonics to the fundamental pattern:</li> </ul> <p>$$   C_2 \\sin(2kx + \\alpha_2) = a_2 \\cos(2kx) + b_2 \\sin(2kx) \\quad \\text{(2nd harmonic)}   $$</p> <p>$$   C_3 \\sin(3kx + \\alpha_3) = a_3 \\cos(3kx) + b_3 \\sin(3kx) \\quad \\text{(3rd harmonic)}   $$</p> <p>To build a non-smooth shape (square wave) with sharp edges and sudden jumps using Fourier Series, we can add sine waves together:</p> <ol> <li>Start with the fundamental sine wave (lowest frequency)</li> <li>Then add harmonics (3x, 5x, 7x the frequency etc)</li> <li>More harmonics you add, the closer the sum looks like a square wave.</li> </ol>"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart1/#general-representation","title":"General representation","text":"<p>The Fourier Series for function \\(f(x)\\) with period \\(L = 2\\pi\\) , fundamental frequency \\(k = \\frac{2\\pi}{L} = 1\\) and involve terms:</p> \\[ a_1 \\cos x, \\quad b_1 \\sin x \\] \\[ a_2 \\cos x, \\quad b_2 \\sin x \\] \\[ a_3 \\cos x, \\quad b_3 \\sin x \\] <p>We also include a constant term \\(\\frac{a_0}{2}\\) to represent a functions entirely above the x-axis and with sufficient number of harmonics, approximate series can exactly represent a give function \\(f(X)\\) :</p> \\[ f(x) = \\frac{a_0}{2} + a_1 \\cos x + a_2 \\cos x + a_3 \\cos x + ... + b_1 \\sin x + b_2 \\sin x + b_3 \\sin x + ... \\] <p>Basically, the Fourier Series of function \\(f(x)\\) with period \\(2\\pi\\) , where n = 1, 2, 3, ... is:</p> \\[ f(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos(nx) + b_n \\sin(nx) \\right] \\] <p>To find the Fourier coefficients (\\(a_0\\) , \\(a_n\\) , \\(b_n\\)) for function \\(f(x)\\) , where integrations are over a single interval in \\(x\\) of \\(L = 2\\pi\\) : </p> <p>Step 1 - $$ a_0 = \\frac{1}{\\pi} \\int_{2\\pi} f(x) \\, dx $$</p> <p>Step 2 - $$ a_n = \\frac{1}{\\pi} \\int_{2\\pi} f(x) \\cos(nx) \\, dx $$</p> <p>Step 3 - $$ b_n = \\frac{1}{\\pi} \\int_{2\\pi} f(x) \\sin(nx) \\, dx $$</p> <p>Note that</p> <p>If we specify a particular value of \\(x\\) in Fourier Series, it will give you a series of constants equal to \\(f(x)\\). </p> <p>If \\(f(x)\\) is discontinuous at \\(x\\) , the series converges to a value half-way between the two possible function values:</p>"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart1/#alternative-representation-1","title":"Alternative representation 1","text":"<p>For waveform \\(f(x)\\) with period \\(L = \\frac{2\\pi}{k}\\) :</p> \\[ f(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos(nkx) + b_n \\sin(nkx) \\right] \\] <p>To find the Fourier coeffiecients where integrations are over a single interval in \\(x\\) of \\(L\\) :  </p> <p>Step 1 - $$ a_0 = \\frac{2}{L} \\int_{L} f(x) \\, dx $$</p> <p>Step 2 - $$ a_n = \\frac{2}{L} \\int_{L} f(x) \\cos(nkx) \\, dx $$</p> <p>Step 3 - $$ b_n = \\frac{2}{L} \\int_{L} f(x) \\sin(nkx) \\, dx $$</p>"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart1/#alternative-representation-2","title":"Alternative representation 2","text":"<p>For waveform \\(f(x)\\) with period \\(2L = \\frac{2\\pi}{k}\\) , \\(k = \\frac{\\pi}{L}\\) and \\(nkx = \\frac{n\\pi x}{L}\\) :</p> \\[ f(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos(\\frac{n\\pi x}{L}) + b_n \\sin(\\frac{n\\pi x}{L}) \\right] \\] <p>To find the Fourier coeffiecients where integrations are over a single interval in \\(x\\) of \\(2L\\) :  </p> <p>Step 1 - $$ a_0 = \\frac{1}{L} \\int_{2L} f(x) \\, dx $$</p> <p>Step 2 - $$ a_n = \\frac{1}{L} \\int_{2L} f(x) \\cos(\\frac{n\\pi x}{L}) \\, dx $$</p> <p>Step 3 - $$ b_n = \\frac{1}{L} \\int_{2L} f(x) \\sin(\\frac{n\\pi x}{L}) \\, dx $$</p>"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart1/#alternative-representation-3","title":"Alternative representation 3","text":"<p>For waveform \\(f(t)\\) with period \\(T = \\frac{2\\pi}{\\omega}\\) :</p> \\[ f(t) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos(n\\omega t) + b_n \\sin(n\\omega t) \\right] \\] <p>To find the Fourier coeffiecients where integrations are over a single interval in \\(t\\) of \\(T\\) :  </p> <p>Step 1 - $$ a_0 = \\frac{2}{T} \\int_{T} f(t) \\, dt $$</p> <p>Step 2 - $$ a_n = \\frac{2}{T} \\int_{T} f(t) \\cos(n\\omega t) \\, dt $$</p> <p>Step 3 - $$ b_n = \\frac{2}{T} \\int_{T} f(t) \\sin(n\\omega t) \\, dt $$</p>"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart1/#useful-trigonometry-results","title":"Useful Trigonometry results","text":"<p>When calculating the Fourier coefficients \\(a_n\\) and \\(b_n\\) , the following trigonometry results deduced from the graph of \\(\\sin x\\) and \\(\\cos x\\) are useful:</p> \\[ \\sin (n\\pi) = 0 \\] \\[ \\cos (n\\pi) = (-1)^n \\] \\[ \\sin\\left(\\frac{n\\pi}{2}\\right) = \\begin{cases} 0, &amp; \\text{if } n \\text{ is even} \\\\ 1, &amp; \\text{if } n = 1, 5, 9, \\ldots \\\\ -1, &amp; \\text{if } n = 3, 7, 11, \\ldots \\end{cases} \\] \\[ \\cos\\left(\\frac{n\\pi}{2}\\right) = \\begin{cases} 0, &amp; \\text{if } n \\text{ is odd} \\\\ 1, &amp; \\text{if } n = 0, 4, 8, \\ldots \\\\ -1, &amp; \\text{if } n = 2, 6, 10, \\ldots \\end{cases} \\] <p>If we integrate over whole periods, areas cancel out: $$ \\int_{2\\pi} \\sin(nx) \\, dx = 0 $$</p> \\[ \\int_{2\\pi} \\cos(nx) \\, dx = 0 \\]"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart2/","title":"Fourier Series: Part 2","text":""},{"location":"ENG2053%20Engineering%20Math%203/FourierPart2/#introduction","title":"Introduction","text":"<p>With the knowledge of even and odd functions, work required to find Fourier Series can be reduced, as some Fourier coefficients \\(a_0\\) , \\(a_n\\) or \\(b_n\\) become zero after integration.</p>"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart2/#fourier-series-for-even-functions","title":"Fourier Series for Even Functions","text":"<p>\\(y = f(t)\\) is even if \\(f(-t) = f(t)\\) for all values of \\(t\\) . Graph is always symmetrical about the y-axis (miror image):</p> <p>For even function \\(f(t)\\) with range \\(-L\\) to \\(L\\) (period \\(= 2L\\) ), this will produce value 0:</p> \\[ b_n = \\frac{1}{L} \\int_{-L}^{L} f(t) \\sin(\\frac{n\\pi t}{L}) \\, dt = 0 \\] <p>Flashback</p> <ul> <li> <p>Product of an even function and an odd function will produce an odd function. </p> </li> <li> <p>Product of two even functions will produce even and product of two odd functions will produce even.</p> </li> </ul> <p>Since for an even function, coefficient \\(b_n\\) has zero value ( \\(b_n = 0\\) ), we only have to calculate \\(a_0\\) and \\(a_n\\) for Fourier Series expansion:</p> \\[ a_0 = \\frac{1}{L} \\int_{-L}^{L} f(t) \\, dt \\] \\[ a_n = \\frac{1}{L} \\int_{-L}^{L} f(t) \\cos\\left( \\frac{n\\pi t}{L} \\right) \\, dt \\] <p>Final Fourier expansion for an even function has cosine terms only: </p> \\[ f(t) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos(\\frac{n\\pi t}{L}) \\right] \\]"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart2/#fourier-series-for-odd-functions","title":"Fourier Series for Odd Functions","text":"<p>\\(y = f(t)\\) is odd if \\(f(-t) = -f(t)\\) for all values of \\(t\\) . Graph is always symmetrical about the origin:</p> <p>For odd function \\(f(t)\\) with range \\(-L\\) to \\(L\\) (period \\(= 2L\\) ), this will produce value 0:</p> \\[ a_n = \\frac{1}{L} \\int_{-L}^{L} f(t) \\cos(\\frac{n\\pi t}{L}) \\, dt = 0 \\] <p>Since for an odd function, coefficient \\(a_n\\) and \\(a_0\\) has zero value ( \\(a_0 = 0\\) &amp; \\(a_n = 0\\) ), we only have to calculate \\(b_n\\) for Fourier Series expansion:</p> \\[ b_n = \\frac{1}{L} \\int_{-L}^{L} f(t) \\sin\\left( \\frac{n\\pi t}{L} \\right) \\, dt \\] <p>Final Fourier expansion for an odd function has sine terms only: </p> \\[ f(t) = \\sum_{n=1}^{\\infty} \\left[ b_n \\sin(\\frac{n\\pi t}{L}) \\right] \\]"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart2/#half-range-fourier-series","title":"Half-Range Fourier Series","text":"<p>If a function is defined over half the range ( \\(0\\) to \\(L\\) ), instead of full range ( \\(-L\\) to \\(L\\) ), it may be expanded in a series of sine terms only or cosine terms only known as half range Fourier Series. This half range definition can be used to analyze Fourier Series of even or odd function. </p>"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart2/#even-function-half-range-cosine-series","title":"Even Function (Half Range Cosine Series)","text":"<p>Even function can be expanded using half its range:</p> <ul> <li>\\(0\\) to \\(L\\) </li> <li>\\(-L\\) to \\(0\\) </li> <li>\\(L\\) to \\(2L\\)</li> </ul> <p>Range of integration is \\(L\\) for half range, instead of the full period of \\(2L\\) :</p> \\[ a_0 = \\frac{2}{L} \\int_{0}^{L} f(t) \\, dt  \\] \\[ a_n = \\frac{2}{L} \\int_{0}^{L} f(t) \\cos(\\frac{n\\pi t}{L}) \\, dt  \\] \\[ b_n = 0 \\] <p>Fourier Series of half range even function:  $$ f(t) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left[ a_n \\cos(\\frac{n\\pi t}{L}) \\right] $$</p> <p>where \\(n = 1, 2, 3, ...\\)</p>"},{"location":"ENG2053%20Engineering%20Math%203/FourierPart2/#odd-function-half-range-sine-series","title":"Odd Function (Half Range Sine Series)","text":"<p>Odd function can be expanded using half its range:</p> <ul> <li>\\(0\\) to \\(L\\) </li> <li>\\(-L\\) to \\(0\\) </li> <li>\\(L\\) to \\(2L\\)</li> </ul> <p>Range of integration is \\(L\\) for half range, instead of the full period of \\(2L\\) :</p> \\[ a_0 = 0 \\] \\[ a_n = 0 \\] \\[ b_n = \\frac{2}{L} \\int_{0}^{L} f(t) \\sin\\left( \\frac{n\\pi t}{L} \\right) \\, dt \\] <p>Fourier Series of half range even function:  $$ f(t) = \\sum_{n=1}^{\\infty} \\left[ b_n \\sin(\\frac{n\\pi t}{L}) \\right] $$</p> <p>where \\(n = 1, 2, 3, ...\\)</p>"},{"location":"ENG2053%20Engineering%20Math%203/Orthogonal/","title":"Integral of Periodic Function \u2013 Orthogonal / Non- Orthogonal","text":""},{"location":"ENG2053%20Engineering%20Math%203/Orthogonal/#even-odd-functions","title":"Even &amp; Odd Functions","text":"<ul> <li>If function is even: \\(f(-x) = f(x)\\)</li> </ul> <p>Example</p> <p>\\(f(x) = x^2\\)  and  \\(g(x) = cos(x)\\) </p> <ul> <li>If function is odd: \\(f(-x) = -f(x)\\)</li> </ul> <p>Example</p> <p>\\(f(x) = x^3\\)  and  \\(g(x) = sin(x)\\) </p> <ul> <li>Sketching of even and odd functions: </li> </ul> <p></p> <p>Facts about intregrals of even/odd functions</p> <p>These facts are only valid on \"symmetric interval\" (Example: [-L,L]) and these facts may not be true if we are not integrating on a \"symmetric interval\": </p> <ul> <li> <p>\\(f(x)\\) is even, then   $$   \\int_{-L}^{L} f(x) dx = 2 \\int_0^L f(x) dx   $$</p> </li> <li> <p>\\(f(x)\\) is odd, then   $$   \\int_{-L}^{L} f(x) dx = 0   $$</p> </li> </ul> <p>Product of even and odd</p> <ul> <li>Odd x Odd = Even</li> <li>Even x Even = Even</li> <li>Odd x Even = Odd</li> </ul>"},{"location":"ENG2053%20Engineering%20Math%203/Orthogonal/#orthogonality-in-fourier-series","title":"Orthogonality in Fourier Series","text":"<ul> <li> <p>In Fourier series, sine and cosine functions are examined for their orthogonality, as it shows how these functions interact over one period.</p> </li> <li> <p>In Fourier series, we represent periodic function as a sum of sines and cosines. </p> </li> <li> <p>Orthogonality ensures each term in this sum corresponds to an independent frequency component, therefore the coefficients of \\(a_n\\), \\(a_0\\) and \\(b_n\\) can be computed seperately without interference. </p> </li> </ul>"},{"location":"ENG2053%20Engineering%20Math%203/Orthogonal/#non-orthogonal-functions","title":"Non-Orthogonal Functions","text":"<ul> <li>Two functions are non-orthogonal if the intergral of their inner product over the interval is nonzero:    $$   \\int_{a}^{b} f(x)g(x) dx \\neq 0   $$</li> </ul> <p>Example</p> 12 <p>Given functions \\(f(x) = x\\) and \\(g(x) = 2x\\): $$ \\int_{0}^{1} f(x)g(x) dx = \\int_{0}^{1} x(2x) dx = 2 \\int_{0}^{1} x^2 dx = \\left. \\frac{2x^3}{3} \\right|_{0}^{1} = \\frac{2}{3} $$</p> <pre><code>Hence, since the product of these functions is not zero, they are non-orthogonal.\n</code></pre> <p>Given functions \\( f(x) = \\cos(x) \\) and \\( g(x) = \\cos(x) + \\cos(3x) \\):</p> \\[ \\begin{align*} \\int_{-\\pi}^{\\pi} f(x)g(x) \\, dx &amp;= \\int_{-\\pi}^{\\pi} \\cos(x) \\left[ \\cos(x) + \\cos(3x) \\right] \\, dx \\\\ &amp;= \\int_{-\\pi}^{\\pi} \\cos^2(x) \\, dx + \\int_{-\\pi}^{\\pi} \\cos(x) \\cos(3x) \\, dx \\end{align*} \\] <p>First integral: $$ \\int_{-\\pi}^{\\pi} \\cos^2(x) \\, dx &gt; 0 $$</p> <p>Second integral: $$ \\int_{-\\pi}^{\\pi} \\cos(x) \\cos(3x) \\, dx = 0 $$</p> <p>Overall result: $$ \\int_{-\\pi}^{\\pi} f(x)g(x) \\, dx = \\text{non-zero} $$</p> <pre><code>Hence, since the product of these functions contains a non-zero component, there are non-orthogonal.\n</code></pre> <p>For your information</p> <p>In Fourier series, if two functions are not orthogonal, they will interfere with each other when decomposing a function, as they do  not exhibit the same clean speration as orthogonal functions making analysis more complex!</p>"},{"location":"ENG2053%20Engineering%20Math%203/Orthogonal/#orthogonal-functions","title":"Orthogonal Functions","text":"<ul> <li>Two non-zero functions are orthogonal if the integral of their inner product over the interval is zero:</li> </ul> <p>$$   \\int_{a}^{b} f(x)g(x) \\, dx = 0   $$</p> <ul> <li>A set of non-zero functions is said to be mutually orthogonal on \\( a \\leq x \\leq b \\), if \\( f_i(x) \\) and \\( f_j(x) \\) are orthogonal for every \\( i \\neq j \\). So:</li> </ul> \\[ \\int_{a}^{b} f_i(x)\\, f_j(x)\\, dx = \\begin{cases}   0       &amp; \\text{if } i \\ne j \\\\   c &gt; 0   &amp; \\text{if } i = j \\end{cases} \\] <p>Extra info</p> Case i \u2260 jCase i = j <ul> <li> <p>Even though the product \\(f_1(x)f_2(x)\\) isn't zero at all points, the positive contributions in some regions are canceled out by negative contributions in others, particularly around where the sine and cosine functions interact.</p> </li> <li> <p>Basically, when you integrate the product \\(f_1(x)f_2(x)\\) over a full period, the total positive and negative areas balance out, resulting in a net integral of zero, confirming that the functions are orthogonal.</p> </li> </ul> <ul> <li>For this case we will get a positive value from the integral, as:</li> </ul> <p>$$   \\int_{a}^{b} f_i(x)f_i(x) \\, dx = \\int_{a}^{b} [f_i(x)]^2 \\, dx &gt; 0   $$</p> <p>Important Note</p> <p>Functions must be non-zero, otherwise:</p> <ul> <li>If \\(f(x) = 0\\), then \\(\\int f(x)g(x) \\, dx = 0\\) for any \\(g(x)\\)</li> <li>This would trivially satisfy the orthogonality condition without meaningful interpretation</li> <li>Truth be told, we only care about non-zero functions being orthogonal because only then do they contribute meaningfully and independently to signal decomposition in Fourier series. </li> </ul>"},{"location":"EPM2003%20Project%20Management/ThingSpeak/","title":"ThingSpeak","text":""},{"location":"EPM2003%20Project%20Management/ThingSpeak/#introduction","title":"Introduction","text":"<p>ThingSpeak is an IoT (Internet of Things) platform that allows users to collect, store, analyze, and visualize sensor data in the cloud. Developed by MathWorks, it is widely used for IoT projects, including environmental monitoring, smart agriculture, industrial automation, and home automation. We will be using in our irrigation control system, where the temperature of the water will be detected and uploaded to the platform, as this will give farm users an easier way to check their temperature of their irrigation system. </p>"},{"location":"EPM2003%20Project%20Management/ThingSpeak/#how-to-start","title":"How to start","text":"<p>To begin using ThingSpeak, we need to first create a new channel. In here, we put in the name of the system, in this case Test Temperature Monitoring, description, which is the general about for the system and fields, where you can put as many as you like, but since we are only doing it for temperature, we have only picked one, which is Temperature. </p>"},{"location":"EPM2003%20Project%20Management/ThingSpeak/#code-for-thingspeak-testing","title":"Code for ThingSpeak Testing","text":"<p>In this part, we will not be using the sensor, as I will be randomly generating some values to replicate the process of temperature sensor reciveing information (water temperature).</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;ThingSpeak.h&gt;\n\nconst char* ssid = \"Your_SSID\";       // Your Network SSID\nconst char* password = \"Your_PASSWORD\";     // Your Network Password\n\nWiFiClient client;\n\nunsigned long myChannelNumber = 2975330; \nconst char * myWriteAPIKey = \"P7N4N8GGXILVWY9P\"; \n\nint val;\n\nvoid setup()\n{\n  Serial.begin(9600);\n  WiFi.begin(ssid, password);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nWiFi connected\");\n\n  // Seed random number generator using analog noise\n  randomSeed(analogRead(A0));\n\n  ThingSpeak.begin(client);\n}\n\nvoid loop()\n{\n  val = random(0, 101);  // Random number between 0 and 100\n  Serial.print(\"Temperature: \");\n  Serial.print(val);\n  Serial.println(\"*C\");\n\n  ThingSpeak.writeField(myChannelNumber, 1, val, myWriteAPIKey);\n\n  delay(15000);  // ThingSpeak requires at least 15s delay between writes\n}\n</code></pre>"},{"location":"EPM2003%20Project%20Management/ThingSpeak/#explanation","title":"Explanation","text":"<p>A. Includes all the necessary libraries for ESP8266 and ThingSpeak</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n#include &lt;WiFiClient.h&gt;\n#include &lt;ThingSpeak.h&gt;\n</code></pre> <ul> <li><code>ESP8266WiFi.h</code>: Enables Wi-Fi connectivity for ESP8266</li> <li><code>WiFiClient.h</code>: Allows the ESP8266 to act as a network client</li> <li><code>ThingSpeak.h</code>: Provides functions to interact with ThingSpeak IoT platform</li> </ul> <p>B. Defining Wi-Fi network credantials</p> <pre><code>const char* ssid = \"Your_SSID\";\nconst char* password = \"Your_PASSWORD\";\n</code></pre> <ul> <li><code>ssid</code>: Name of your Wi-Fi network (case sensitive)</li> <li><code>password</code>: Password for the network</li> <li>Replace <code>Your_SSID</code> and <code>Your_PASSWORD</code> with your actual credentials</li> </ul> <p>Danger</p> <p>For your SSID and passwork, try not to use special character such as ' or ` </p> <p>C. ThingSpeak Configuration</p> <pre><code>WiFiClient client;\nunsigned long myChannelNumber = 2975330; \nconst char * myWriteAPIKey = \"P7N4N8GGXILVWY9P\";\n</code></pre> <ul> <li><code>client</code>: Creates a Wi-Fi client object to handle connections</li> <li><code>myChannelNumber</code>: Your ThingSpeak channel ID (replace with your own)</li> <li><code>myWriteAPIKey</code>: Your ThingSpeak Write API Key (keep this private)</li> </ul> <p>D. Global Variables</p> <pre><code>int val;\n</code></pre> <ul> <li><code>val</code>: Stores the random \"temperature\" value to be sent to ThingSpeak</li> </ul> <p>E. <code>setup()</code> Function</p> <pre><code>void setup()\n{\n  Serial.begin(9600);\n  WiFi.begin(ssid, password);\n</code></pre> <ul> <li><code>Serial.begin(9600)</code>: Starts serial communication for debugging (baud rate = 9600)</li> <li><code>WiFi.begin(ssid, password)</code>: Attempts to connect to the specified Wi-Fi network</li> </ul> <p>F. Wi-Fi Connection Loop</p> <pre><code>while (WiFi.status() != WL_CONNECTED) {\n  delay(500);\n  Serial.print(\".\");\n}\nSerial.println(\"\\nWiFi connected\");\n</code></pre> <ul> <li><code>while</code> loop: Waits until Wi-Fi is connected, printing dots (<code>...</code>) every 500ms</li> <li><code>WiFi.status()</code>: Checks the connection status (<code>WL_CONNECTED</code> means success)</li> <li>Prints \"<code>WiFi connected</code>\" once linked</li> </ul> <p>G. Random Seed Initialization</p> <pre><code>randomSeed(analogRead(A0));\n</code></pre> <ul> <li><code>randomSeed()</code>: Seeds the random number generator using noise from analog pin <code>A0</code> (unconnected pin = floating voltage for randomness)</li> </ul> <p>H. ThingSpeak Initialization</p> <pre><code>ThingSpeak.begin(client);\n</code></pre> <ul> <li>Starts the ThingSpeak client using the <code>WiFiClient</code> object</li> </ul> <p>I. <code>loop()</code> Function</p> <pre><code>void loop()\n{\n  val = random(0, 101);  // Random number between 0 and 100\n</code></pre> <ul> <li><code>random(0, 101)</code>: Generates a pseudo-random integer between 0 and 100 (simulates temperature)</li> </ul> <p>J. Serial Monitor Output</p> <pre><code>Serial.print(\"Temperature: \");\nSerial.print(val);\nSerial.println(\"*C\");\n</code></pre> <ul> <li>Prints the random value as a \"temperature\" (e.g., <code>Temperature: 42*C</code>)</li> </ul> <p>K. Send Data to ThingSpeak</p> <pre><code>ThingSpeak.writeField(myChannelNumber, 1, val, myWriteAPIKey);\n</code></pre> <ul> <li><code>writeField()</code>: Sends <code>val</code> to Field 1 of your ThingSpeak channel</li> <li>The arguments are <code>(channelNumber, fieldNumber, data, APIKey)</code></li> </ul> <p>L. Delay Between Writes</p> <pre><code>delay(15000);  // ThingSpeak requires at least 15s delay between writes\n</code></pre> <ul> <li>We need this line, as ThingSpeak only accepts data every 15 seconds due to free account limitation </li> </ul>"},{"location":"EPM2003%20Project%20Management/ThingSpeak/#expected-output","title":"Expected Output","text":"<p>So, the serial monitor will show:</p> <pre><code>....\nWiFi connected\nTemperature: 64*C\nTemperature: 12*C\n...\n</code></pre> <p>In your ThingSpeak Channel, it will show: A graph of random values (0\u2013100) updating every 15 seconds</p>"},{"location":"EPM2003%20Project%20Management/ThingSpeak/#demo","title":"Demo","text":"<p>To review the demo, please click this link: View ThingSpeak Channel</p>"},{"location":"EPM2003%20Project%20Management/wifi/","title":"Wifi","text":""},{"location":"EPM2003%20Project%20Management/wifi/#introduction","title":"Introduction","text":"<p>Since we are using the NodeMCU ESP8266 which is widely used for IoT (Internet of Things projects), it has built-in Wi-Fi, hence making it ideal for connecting devices to the internet. </p>"},{"location":"EPM2003%20Project%20Management/wifi/#code-for-wifi-testing","title":"Code for Wifi Testing","text":"<p>To use the built-in Wi-Fi, we first wrote some codes and uploaded the codes to the NodeMCU ESP8266 to test out the built in wifi. </p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n\nconst char* ssid = \"Your_SSID\";\nconst char* password = \"Your_PASSWORD\";\n\nvoid setup() {\n  Serial.begin(9600);\n  WiFi.begin(ssid, password);\n  Serial.print(\"Connecting\");\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\\nConnected!\");\n  Serial.println(WiFi.localIP());\n}\n\nvoid loop() {}\n</code></pre>"},{"location":"EPM2003%20Project%20Management/wifi/#explanation","title":"Explanation","text":"<p>A. Includes the ESP8266 Wi-Fi library, which provides functions to connect to Wi-Fi networks</p> <pre><code>#include &lt;ESP8266WiFi.h&gt;\n</code></pre> <p>B. Defining Wi-Fi network credantials</p> <pre><code>const char* ssid = \"Your_SSID\";\nconst char* password = \"Your_PASSWORD\";\n</code></pre> <ul> <li><code>ssid</code>: Name of your Wi-Fi network (case sensitive)</li> <li><code>password</code>: Password for the network</li> <li>Replace <code>Your_SSID</code> and <code>Your_PASSWORD</code> with your actual credentials</li> </ul> <p>Danger</p> <p>For your SSID and passwork, try not to use special character such as ' or ` </p> <p>C. The <code>setup()</code> function runs once when the board starts. It initializes settings</p> <pre><code>void setup(){\n</code></pre> <p>D. Starts serial communication at 9600 baud rate for debugging</p> <pre><code>Serial.begin(9600);\n</code></pre> <p>Tip</p> <p>You can also use <code>Serial.begin(115200)</code> for faster communication (common in ESP8266).</p> <p>E. Attempts to connect to the Wi-Fi network using the provided <code>ssid</code> and <code>password</code></p> <pre><code>WiFi.begin(ssid, password);\n</code></pre> <p>Notes</p> <p>This is non-blocking (the code continues while connecting in the background).</p> <p>F. Prints <code>\"Connecting\"</code> to the Serial Monitor to indicate the connection attempt</p> <pre><code>Serial.print(\"Connecting\");\n</code></pre> <p>G. Waits until the Wi-Fi connection is established</p> <pre><code>while (WiFi.status() != WL_CONNECTED) {\n  delay(500);\n  Serial.print(\".\");\n}\n</code></pre> <ul> <li><code>WiFi.status()</code>: checks the connection status</li> <li><code>WL_CONNECTED</code>: successfully connected</li> <li>The loop prints dots (<code>...</code>) every 500ms while waiting. </li> </ul> <p>Notes</p> <p>This is a blocking loop (code pauses here until connected).</p> <p>H. Prints <code>\"Connected!\"</code> on a new line (<code>\\n</code>) once the Wi-Fi is connected</p> <pre><code>Serial.println(\"\\nConnected!\");\n</code></pre> <p>I. Prints the local IP address assigned to the ESP8266 by the router</p> <pre><code>Serial.println(WiFi.localIP());\n</code></pre> <p>Example</p> <p><code>192.168.1.100</code> (your IP will vary)</p> <p>J. The <code>loop()</code> function runs repeatedly after <code>setup()</code></p> <pre><code>void loop() {}\n</code></pre>"},{"location":"EPM2003%20Project%20Management/wifi/#key-points","title":"Key points","text":"<p>Info</p> <ul> <li>Make sure to double-check ssid / password</li> <li>Ensure the Wi-Fi is 2.4 GHz (ESP8266 doesn't support 5 GHz)</li> </ul>"},{"location":"EPM2003%20Project%20Management/wifi/#expected-output","title":"Expected Output","text":"<p>A. When the ESP8266 starts connecting:</p> <pre><code>Connecting\n</code></pre> <p>B. While waiting for connection (every 500ms):</p> <pre><code>....\n</code></pre> <ul> <li>Dots (<code>.</code>) appear repeatedly until the connection is established.</li> <li>Each dot represents a 500ms delay <code>(delay(500))</code>.</li> <li>Example: If it takes 2 seconds to connect, you\u2019ll see <code>....</code> (4 dots)</li> </ul> <p>C. Once connected: </p> <pre><code>Connected!\n192.168.1.100\n</code></pre> <ul> <li>\"Connected!\" confirms a successful Wi-Fi link.</li> <li>The next line shows the local IP address assigned by your router.</li> </ul> <p>So, The full output will be: <pre><code>Connecting....\nConnected!\n192.168.1.100\n</code></pre></p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/","title":"Chapter 3: Rectifier","text":""},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#ac-to-dc-conversion","title":"AC to DC Conversion","text":"<p>Output DC voltage is used to power most electronic circuits, including consumer electronics, computers, industrial controllers, and laboratory instrumentation systems and equipment. Rectifier can be either a half-wave rectifier or full-wave rectifier. Rectifier converts AC input voltage to pulsating DC voltage. Filter then eliminates the fluctuations in the rectified voltage and produces a relatively smooth dc voltage. Regulator then maintains a constant dc voltage for variations in the input line voltage or in the load. </p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#half-wave-rectifier","title":"Half-wave Rectifier","text":"<p>A diode is connected to an ac source and to a load resistor, \\(R_L\\) forming a half-wave rectifier.</p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#ideal-model","title":"Ideal Model","text":"<p>If we use an ideal model for the diode, we basically ignore the voltage drop of the diode, as the the diode is a short circuit <code>R = 0 \u03a9</code> when forward-biased and open circuit <code>R = \u221e \u03a9</code> when reversed-biased. </p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#constant-voltage-drop-model","title":"Constant Voltage Drop Model","text":"<p>If we use a constant voltage drop model for the diode, we have to take into account the voltage drop , \\(V_D\\) when forward biased of the diode as a constant value, typically around 0.7 V for silicon diode and 0.3 V for germanium diode. This can be shown in the graph below, where \\(V_D\\) is the constant voltage drop of diode:</p> <p>Barrier Potential</p> <p>Basically, when using a diode, input voltage must overcome the barrier potential or voltage drop of 0.7 V (silicon) before diode can become forward-biased. This results in a output, \\(V_O\\) with peak value that is 0.7 V less than peak value of input, \\(V_S\\) : $$ V_{O} = V_{S} - 0.7 V $$  </p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#operation","title":"Operation","text":"<ul> <li>Using the Constant Voltage Drop Model, when the sinusoidal input voltage, \\(V_S\\) goes positive, diode is forward-biased and conducts current. Current passes through load resistor and produces an output voltage across the load resistor, which is the \\(V_O\\) or \\(V_S - V_D\\) in the graph:  </li> </ul> <ul> <li>Using the Constant Voltage Drop Model, when the sinusoidal input voltage, \\(V_S\\) goes negative during the second half of its cycle, diode is reversed-biased and source voltage appears across the diode (Diode takes all the voltage). There is no current, so voltage across load resistor is 0 V, hence producing \\(V_O\\) or \\(V_S - V_D\\) of 0 V. The net result is that only positive half-cycles of AC input voltage appear across the load:</li> </ul> <ul> <li> <p>Since, the \\(V_O\\) does not change polarity, it is a pulsating dc voltage. </p> </li> <li> <p>If we were using an Ideal Diode Model, the graph would look the same as the output Constant Voltage Drop Model, but the \\(V_O\\) will not be considering the voltage drop of diode, hence during the positive cycle, the \\(V_O\\) will be just the \\(V_S\\) or same as the source voltage in the graph above, while for Constant Voltage Drop Model, it will be \\(V_S - V_D\\). </p> </li> </ul> <p>Info</p> <p>It is usually acceptable to use the ideal diode model, which neglects the effect of barrier potential (voltage drop), when the peak value of applied voltage is much greater than the barrier potential (voltage drop) </p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#consideration-for-diode-selection","title":"Consideration for diode selection","text":""},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#diodes-current-handling-capability","title":"Diode's current-handling capability","text":"<ul> <li>Refers to the maximum forward current it can safely conduct without damage. </li> <li>During the positive half-cycle of input AC Voltage, the diode conducts current to the load. This current must not exceed the diode's rated \\(I_F\\).</li> <li>This is because excessive current raises the diode's internal temperature.</li> </ul> <p>Example</p> <p>If the input AC peak current, \\(I_{peak} = 100 mA\\), the diode's rated \\(I_F\\) must be \\(&gt; 100 mA\\)</p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#diodes-peak-inverse-voltage-piv","title":"Diode's peak inverse voltage (PIV)","text":"<ul> <li>Refers to the maximum reverse voltage across the diode during the negative half-cycle.</li> <li>It is used to determine the maximum reverse voltage (PIV rating) the diode can withstand without breaking down.</li> <li>During the negative half-cycle, the diode is reverse-biased. The diode takes the entire voltage from the source when it is reverse-biased according to Kirchoff's Voltage Law, as voltage across resistor is zero. </li> <li>The PIV rating of the diode must be at least the peak input voltage, \\(V_{peak}\\).</li> <li>If the reverse voltage exceeds diode's PIV rating, breakdown of diode can occur, potentially damaging or destroying the diode. </li> </ul> <p>Recommendation</p> <p>It is recommeneded to have \\(V_{BR} &gt; 1.5 PIV\\), where \\(V_{BR}\\) is the diode's reverse breakdown voltage. This is to provide a safety margin for voltage spikes or transients. </p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#example-consideration-with-graphs","title":"Example consideration with graphs","text":"<p>To calculate the peak current through the diode during the positive half-cycle: $$ I_{\\text{forward}} = \\frac{V_S - V_D}{R_{\\text{load}}} $$ Where, \\(V_S\\) : Peak Source Voltage, \\(V_D\\) : Diode's Forward Voltage Drop (\u2248 0.7 V), \\(R_{load}\\) : Load Resistance</p> <p>Hence, diode's current rating, \\(I_F\\) must exceed the value of \\(I_{\\text{forward}}\\) . </p> <p>Example</p> <p>If \\(I_{\\text{forward}} = 93 mA\\) , then we must select a diode with \\(I_F &gt; 93 mA\\) </p> <p>To find PIV for diode: $$ PIV = V_{peak} $$ Where, \\(V_{peak}\\) is the peak input voltage, \\(V_S\\)</p> <p>Hence, diode's PIV rating or \\(V_{BR}\\) must be more than \\(1.5 PIV\\) .</p> <p>Example</p> <p>If \\( V_S = 10\\,\\text{V} \\), then the peak inverse voltage (PIV) is also \\( 10\\,\\text{V} \\). We must choose a diode with a breakdown voltage \\( V_{\\text{BR}} \\) greater than 1.5 times the PIV:</p> \\[ V_{\\text{BR}} &gt; 1.5 \\times 10\\,\\text{V} = 15\\,\\text{V} \\]"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#full-wave-rectifier","title":"Full-wave Rectifier","text":"<p>Full-wave rectifier allows unidirectional (one-way) current through the load during the entire 360\u00b0 of the input cycle. Whereas, half-wave rectifier only allows current through the load only during one-half of the cycle. Thus, full-wave rectification will produce an output voltage with a frequency twice the input frequency and pulsates every half-cycle of input.</p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#ideal-model_1","title":"Ideal Model","text":"<p>If we use an ideal model for the diode, we basically ignore the voltage drop of the diode, as the the diode is a short circuit <code>R = 0 \u03a9</code> when forward-biased and open circuit <code>R = \u221e \u03a9</code> when reversed-biased same like what it is used for in half-wave rectifier. </p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#constant-voltage-drop-model_1","title":"Constant Voltage Drop Model","text":"<p>If we use a constant voltage drop model for the diode in full-wave rectifier, we have to take into account the voltage drop , \\(V_D\\) when forward biased of the diode as a constant value, typically around 0.7 V for silicon diode and 0.3 V for germanium diode. </p> <p>Looking at the graph below, the slopes are \u00b11, as a full-wave rectifier inverts the negative half of the input sine wave so that both positive and negative inputs produce a positive output for the resistor: $$ V_{out} = |V_{in}| $$</p> <p>Hence, </p> \\[ V_{out} =  \\begin{cases} V_{in} &amp; \\text{if } V_{in} &gt; 0 \\quad (\\text{Slope} = +1) \\\\ -V_{in} &amp; \\text{if } V_{in} &lt; 0 \\quad (\\text{Slope} = -1) \\end{cases} \\] <p>Graphically, this forms a V-shaped curve, where the output mirrors the input during the positive half and flips it during the negative half. The curve near the origin is slightly flatenned, meaning no output until \\(|V_{in}|\\) exceeds the diode drops, \\(V_D\\). This can be shown in the graph below, where \\(V_D\\) is the constant voltage drop of diode:</p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#center-tapped-full-wave-rectifier-operation","title":"Center-Tapped Full-Wave Rectifier Operation","text":"<ul> <li>Center-tapped rectifier is a type of full-wave rectifier that uses two diodes connected to the secondary of a center-tapped transformer:</li> </ul> <p>Why Center-Tapped</p> <p>Half of the total secondary voltage appears between the center tap and each end of the secondary winding (Each side have same number of turns, producing 2 equal halves)</p> <ul> <li> <p>Using a ideal diode model, during the positive half-cycle of input voltage, diode \\(D_1\\) is forward-biased and diode \\(D_2\\) is reverse-biased. Since, it is ideal diode, there will be no voltage drop across the diode. The current path is through \\(D_1\\) and load resistor \\(R_L\\). Basically, the output waveform will be \\(V_S\\) same as the postiive half-cycle of input voltage. </p> </li> <li> <p>Using a ideal diode model, during the negative half-cycle of input voltage, diode \\(D_1\\) is reverse-biased and diode \\(D_2\\) is forward-biased. Since, it is ideal diode, there will be no voltage drop across the diode. The current path is through \\(D_2\\) and load resistor \\(R_L\\). Basically, the output waveform will be \\(V_S\\) same as the postive half-cycle of input voltage. </p> </li> <li> <p>As a result, the output current during both positive and negative portions of the input cycle through the load will be in the same direction, hence output voltage across load resistor is a full-wave rectified dc voltage.</p> </li> <li> <p>On the other hand, if we were using a constant voltage drop diode model, the process will be the same as the ideal diode model, but we would have to consider the constant forward voltage drop across the diode, \\(V_D\\) during forward-biased, which are around 0.7 V for silicon diode and 0.3 V for germanium diode. Hence, the output peak value will be \\(V_S - V_D\\) for the complete cycle just like in the graph below. </p> </li> <li> <p>Graph during the positive half-cycle of input voltage:</p> </li> </ul> <ul> <li>Graph during the negative half-cycle of input voltage:</li> </ul> <ul> <li>Graph of full complete waveform:</li> </ul> <p>Ideal diode model</p> <p>For Ideal diode model, instead of \\(V_S - V_D\\) , it will be just \\(V_S\\) , same value as the input voltage for both cycles.  </p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#center-tapped-full-wave-rectifier-piv","title":"Center-Tapped Full-Wave Rectifier PIV","text":"<p>In a center-tapped rectifier, during the positive half-cycle, one diode \\(D_1\\) conducts and in forward-biased, while the other diode \\(D_2\\) is in reverse-biased. Meanwhile, during the negative half-cycle, the vice versa happens. </p> <p>To derive the Peak Inverse Voltage (PIV) for diodes in a center-tapped full-wave rectifier: </p> <p>When diode \\( D_2 \\) is in reverse bias, the voltage across \\( D_2 \\) is:</p> \\[ V_{D2} = V_O - (-V_S) \\] <p>The waveform reaches its peak/maximum value when \\( V_O = V_S - V_D \\).  </p> <p>Since \\( D_2 \\) is reverse-biased, \\( V_{D2} = \\text{PIV} \\):</p> \\[ \\begin{align*} \\text{PIV} &amp;= V_O - (-V_S) \\\\            &amp;= V_O + V_S \\end{align*} \\] <p>Substituting \\( V_O = V_S - V_D \\):</p> \\[ \\begin{align*} \\text{PIV} &amp;= (V_S - V_D) + V_S \\\\            &amp;= 2V_S - V_D \\end{align*} \\] <p>Final Equation for Center-Tapped Full Wave Rectifier</p> <p>PIV (Peak Inverse Voltage) is the maximum reverse voltage of the diode when reverse-biased. Hence in this case, for center-tapped full wave rectifier, it is \\( \\text{PIV} = 2V_S - V_D \\) .  </p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#bridge-full-wave-rectifier-operation","title":"Bridge Full-Wave Rectifier Operation","text":"<ul> <li>Bridge Full-Wave Rectifier is a full-wave rectifier without the need of a center-tapped transformer. It uses 4 diodes, with arrangements similar to Wheatstone bridge:</li> </ul> <ul> <li> <p>Using an ideal-diode model, when the input cycle is positive, diodes \\(D_1\\) and \\(D_2\\) are forward-biased and conduct current. A voltage is developed across the resistor and same like the positive half of the input cycle since we do not have to consider the voltage drop across the diode. During this time, diodes \\(D_3\\) and \\(D_4\\) are reverse-biased. </p> </li> <li> <p>Using an ideal-diode model, when the input cycle is negative, diodes \\(D_3\\) and \\(D_4\\) are forward-biased and conduct current in the same direction as positive half-cycle through the resistor. A voltage is developed across the resistor and same like the positive half of the input cycle (because same current direction) since we do not have to consider the voltage drop across the diode. During this time, diodes \\(D_1\\) and \\(D_2\\) are reverse-biased. As a result, a full-wave rectified output voltage appears across the resistor. </p> </li> <li> <p>Using a constant voltage drop diode model, the process of the rectification will be the same as the ideal-diode model, but we have to consider the constant voltage drop across the diodes. Looking at the process illustration below, 2 diodes are always in series with the load resistor, whether it is positive or negative half-cycles. So, if we take into account the diode drops, the output voltage is: $$ V_O = V_S - 2V_D $$</p> </li> <li> <p>Graph during the positive half-cycle of input voltage:</p> </li> </ul> <ul> <li>Graph during the negative half-cycle of input voltage:</li> </ul> <ul> <li>Graph of full complete waveform:</li> </ul> <p>Ideal diode model</p> <p>For Ideal diode model, instead of \\(V_S - 2V_D\\) , it will be just \\(V_S\\) , same value as the input voltage for both cycles.   </p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#bridge-full-wave-rectifier-piv","title":"Bridge Full-Wave Rectifier PIV","text":"<p>To derive the PIV for Bridge Full-Wave Rectifier, we look at the circuit during positive input cycle, when diodes \\(D_1\\) and \\(D_2\\) are forward-biased and diodes \\(D_3\\) and \\(D_4\\) are reverse-biased:</p> <p>Voltage after \\(D_2\\) is</p> \\[ 0 - V_{D2} = -V_{D2} \\] <p>This is also the voltage on the left side of \\(D_3\\) . </p> <p>Voltage on the right side of \\(D_3\\) is \\(V_O\\), due to the ground being on the other side of the resistor. </p> <p>When \\(D_3\\) is in reverse-biased, reverse voltage across \\(D_3\\) is</p> \\[ V_{D3} = V_O - (-V_{D2}) \\] <p>The waveform reaches its peak/maximum value when</p> \\[ V_{O} = V_S - 2V_{D} \\] <p>Since \\( D_3 \\) is reverse-biased, we can use \\( V_{D3} = \\text{PIV} \\):</p> \\[ \\begin{align*} \\text{PIV} &amp;= V_O - (-V_{D2}) \\\\            &amp;= V_O + V_{D2} \\end{align*} \\] <p>Substituting \\( V_O = V_S - 2V_D \\) and assuming that all diodes are the same:</p> \\[ \\begin{align*} \\text{PIV} &amp;= (V_S - 2V_D) + V_D \\\\            &amp;= V_S - V_D \\end{align*} \\] <p>Final Equation for Bridge Full Wave Rectifier</p> <p>PIV (Peak Inverse Voltage) is the maximum reverse voltage of the diode when reverse-biased. Hence in this case, for bridge full wave rectifier, it is \\( \\text{PIV} = V_S - V_D \\) .  </p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#peak-rectifier","title":"Peak Rectifier","text":""},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#introduction","title":"Introduction","text":"<ul> <li> <p>Rectified waveform removes the segments of negative input waveform and produces a pulsating DC output. </p> </li> <li> <p>This pulsating DC output is still unsuitable as a dc power supply, as the voltage constantly varies between peak voltage and zero due to its pulsating nature. </p> </li> </ul> <p>This pulsating nature can be resolved with a filter capacitor:</p> <ol> <li>The capacitor is placed in parallel with the load to smooth the output voltage.</li> <li>The capacitor charges during voltage peaks and discharges during voltage valleys.</li> <li>This helps to reduce the ripple voltage (i.e., the remaining small fluctuations).</li> <li>As a result, the capacitor filter smooths the output voltage to a near-constant DC.</li> </ol>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#operation-ideal-diode-capacitor","title":"Operation (Ideal diode &amp; capacitor)","text":"<ul> <li> <p>Ideal diode: Zero voltage drop when forward-biased, infinite resistance when reverse-biased</p> </li> <li> <p>Ideal capacitor: No leakage, infinite resistance when fully charged (i.e., holds charge forever unless discharged through a load)</p> </li> <li> <p>At \\(t = 0\\), the capacitor voltage \\(v_C = 0 V\\) (Uncharged). As the AC input voltage \\(v_s\\) starts increasing from 0 toward its positive peak, the diode becomes forward-biased when \\(v_s &gt; V_C\\) (which is initially 0). The diode conducts and charges the capacitor:</p> </li> </ul> <ul> <li> <p>The capacitor continues charging as long as \\(v_s\\) is increasing and greater than \\(V_C\\). Once the input voltage reaches its peak, say \\(V_{peak}\\), the capacitor charges up to this value: $$ V_C = V_S = V_{peak} $$</p> </li> <li> <p>After the input voltage begins to drop below the peak, \\(v_s &lt; V_C\\), hence diode becomes off and no current flows anymore. Because the capacitor is ideal, it does not discharge (no leakage), so it holds its voltage at \\(V_{peak}\\) indefinetly:</p> </li> </ul> <ul> <li>Since the diode is off and in reverse-biased, the capacitor is isolated and maintain its voltage: $$ V_O = V_C = V_S  $$</li> </ul> <ul> <li>During the next cycles of the AC waveform, diode will only turn on again if \\(v_s\\) rises above the stored \\(V_C\\). But since \\(v_s\\) never exceeds the peak again (or only does so momentarily), the diode remains mostly off due to ideal capacitor characteristics. Thus, output voltage remains at \\(V_S\\) or \\(V_{peak}\\):</li> </ul> <p>Why so</p> <p>Now, when the ideal capacitor gets fully charged, the circuit is effectively an open circuit. Hence, there is no way for current to flow. </p> <p>Unless....</p> <p>Unless there's a load, in which case the capacitor might discharge slightly and get \"topped up\" when \\(v_s &gt; V_C\\)</p> <ul> <li>Since the \\(V_O\\) is a DC voltage equal to the peak of the input wave, the circuit is known as peak rectifier or peak detector:</li> </ul> <p>For your information</p> <p>Peak rectifier or peak detector is commonly used in signal processing, power supply smoothening and precision rectifier circuits.</p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#operation-ideal-diode-but-normal-capacitor","title":"Operation (Ideal diode, but normal capacitor)","text":"<ul> <li> <p>A more practical implementation includes a load resistance R connected across a normal capacitor C. </p> </li> <li> <p>Ideal Diode: No voltage drop when forward-biased and infinite resistance when reverse-biased.</p> </li> <li> <p>Capacitor: Stores charges, but can now discharge through load resistor R.</p> </li> <li> <p>Resistor R: Represents the load across which output is taken. </p> </li> <li> <p>Output Voltage, \\(V_O = V_C\\) which is the voltage of the capacitor. </p> </li> <li> <p>At \\(t = 0\\) , \\(V_C = 0\\) , capacitor is initially uncharged. The diode becomes forward-biased as soon as \\(v_s &gt; 0\\) , conducts current and the capacitor charges up as long as \\(v_s &gt; V_C\\) :</p> </li> </ul> <ul> <li> <p>The capacitor tracks the input voltage while it's rising. When the input voltage reaches its peak, the capacitor charges fully: $$ V_C = V_S = V_{peak}  $$</p> </li> <li> <p>After the input voltage passes the peak and starts to fall, \\(v_s &lt; V_C\\) , so diode becomes reverse-biased. At this point, the capacitor begins to discharge through resistor R. The voltage across the capacitor drops exponentially: \\(V_{C}(t) = V_{\\text{peak}} e^{-\\frac{t}{RC}}\\) , until the diode turns on again in the next cycle:</p> </li> </ul> <ul> <li>Capacitor continue to discharge, as the diode is still off and in reverse-biased. At this point, there is no current flow from the source, but the capacitor continues to power the load R and the output voltage (capacitor voltage) gradually drops even more during this time:</li> </ul> <ul> <li>In the next cycle, when the input voltage again excceds the decayed capacitor voltage, \\(v_s &gt; V_{C}(t)\\) , the diode becomes forward-biased again and the capacitor is topped up and charged back to the new peak value of \\(V_S\\) :</li> </ul> <ul> <li>The cycle repeats itself:</li> </ul> <ul> <li>As a result, the output voltage, \\(V_O = V_C\\) is not perfectly flat, but a rippled DC: </li> </ul> <p>Note</p> <p>Basically, the capacitor:</p> <ul> <li>quickly charges to the peak when the diode conducts </li> <li>discharges slowly through R until the next peak </li> </ul> <p>Which results in small ripples around the peak voltage and the amount of ripple depends on R &amp; C: </p> \\[ V_{\\text{ripple}} \\propto \\frac{1}{RC} \\] <ul> <li>Larger C: Slower discharge &amp; less ripple</li> <li>Larger R: smaller load current &amp; less ripple</li> </ul>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#derivation-of-filter-circuit-half-wave","title":"Derivation of filter circuit (Half-wave)","text":"<p>In an RC filter circuit, \\(v_c\\) decays exponentiatlly over time with time constant \\(\u03c4 = CR\\) , where C is the capacitance and R is the resistance. Voltage for capacitor at any time t is given by:</p> \\[ v_c = V_C \\cdot e^{-\\frac{t}{\\tau}} \\] <p>where, \\(V_C\\) is the initial peak voltage across the capacitor.</p> <p>Flashback</p> <p>When t = \u03c4 = RC, \\(v_c\\) drops to \u2248 36.8% of peak voltage \\(V_C\\) :</p> \\[ e^{-\\frac{RC}{RC}} = e^{-1} \\approx 0.368 \\] <p>In basic terms, the time constant, \u03c4 determines how quickly the capacitor discharges. After one time constant (1\u03c4), the voltage of capacitor reduces to about 36.8% of its initial value.   </p> <p>Time constant, \u03c4 is important in an RC filter circuit for maintaining a stable and reliable DC output voltage. In an RC circuit, the capacitor charges and discharges through the capacitor. A larger \u03c4 (achieved by increasing C or R) results in slower voltage changes across capacitor. If \\(CR &gt;&gt; T\\) , where T is the period of the input waveform, it ensures that the capacitor does not discharge significantly during T, hence minimizing ripple:</p> \\[\\begin{align*} e^{-\\frac{T}{\\tau}} &amp;= e^{-\\frac{T}{RC}} \\\\ \\text{If } RC &amp;\\gg T, \\text{ then } \\frac{T}{RC} \\to 0 \\Rightarrow e^{-\\frac{T}{RC}} \\to 1 \\end{align*}\\] <p>So, the larger the \u03c4, the smaller the change in \\(V_C\\) : </p> <p>For your information</p> <p>While larger R or C improves filtering, it may also slow the circuit's response to load changes. Besides, larger C increases cost or size and larger R lowers output current capability.  </p> <p>When a capacitor discharges through a resistor in an RC filter circuit, the output voltage decays slightly between input pulses. This decay causes a small fluctuation called the ripple voltage, \\(V_r\\). To minimize ripple and keep \\(V_r\\) small, CR must be large to ensure the capacitor discharges very slowly: </p> <p>Approximation for calculating DC output voltage (\\(V_O\\)) in an RC filter circuit, accounting for ripple voltage \\(V_r\\) :</p> <ul> <li>The capacitor discharges between input pulses, causing the output to drop from \\(V_S\\) to \\(V_S - V_r\\) . </li> <li>The average of these extremes (\\(V_S\\) and \\(V_S - V_r\\)) gives the DC output: $$  V_O = \\frac{V_S + (V_S - V_r)}{2} = V_S - \\frac{1}{2} V_r $$ Where: \\( V_S \\): Peak voltage (maximum value of the unfiltered input, e.g., rectified AC) \\( V_r \\): Peak-to-peak ripple voltage (fluctuation due to capacitor discharge) \\( V_O \\): Average DC output voltage after filtering</li> </ul> <p>In the formula above, \\(V_O\\) is basically the midpoint of the ripple extremes.</p> <p>Warning</p> <p>This formula works by assuming that:</p> <ul> <li>Linear discharge (valid if \\(CR &gt;&gt; T\\) , only small ripple)</li> <li>Symmetric ripple waveform (sawtooth or triangular approximation)</li> </ul> <p>Relationship between ripple voltage \\(V_r\\) , time constant \\(\\tau\\) and input period \\(T\\): </p> <ul> <li>During the discharge phase of an RC filter circuit, where diode is cut-off and not conducting, output voltage decays exponentially: </li> </ul> \\[ v_o = V_S \\cdot e^{-\\frac{t}{CR}} \\] <p>where, \\(V_S\\) is the peak voltage.</p> <ul> <li>At the end of discharging (after time T), output reaches its minimum:</li> </ul> \\[ V_S - V_r \\approx V_S e^{\\frac{-T}{CR}} \\] <p>where, \\(V_r\\) is the voltage drop during discharge / ripple voltage.</p> <ul> <li> <p>As \\(CR &gt;&gt; T\\) , \\(\\frac{T}{CR}\\) is very small, hence we can use the approximation of: $$ e^{\\frac{-T}{CR}} \\approx 1 - \\frac{T}{CR} $$</p> </li> <li> <p>Substituting into the discharge equation we get: $$ V_S - V_r \\approx V_S \\left(1 - \\frac{T}{CR} \\right) $$</p> </li> </ul> \\[ V_r \\approx V_S \\cdot \\frac{T}{CR} \\] <p>Interpretation</p> <p>Final equation to find ripple voltage:</p> \\[ V_r \\approx V_S \\cdot \\frac{T}{CR} \\] <p>Looking at this equation, ripple voltage \\(V_r\\) decreases if:</p> <ul> <li>C or R increases (larger time constant)</li> <li>T decreases</li> </ul> <ul> <li> <p>As frequency \\(f\\) is the reciprocal of cycle period \\(T\\) , \\(f = \\frac{1}{T}\\) , we substitute this into the formula to find \\(V_r\\) : $$ V_r \\approx V_S \\cdot \\frac{T}{CR} = \\frac{V_S}{fCR} $$</p> </li> <li> <p>With \\(V_r &lt;&lt; V_S\\) (small ripple), we can assume that capacitor discharges with a constant current: $$ I_L = \\frac{V_S}{R} $$</p> </li> <li> <p>If we subsitute this constant current \\(I_L\\) into the formula for \\(V_r\\) :  $$ V_r = \\frac{I_LT}{C} = \\frac{I_L}{fC} $$</p> </li> </ul> <p>Interpretation</p> <p>Alternative equation to find ripple voltage:</p> \\[ V_r = \\frac{I_L}{fC} \\] <p>Looking at this equation, ripple voltage \\(V_r\\) decreases if:</p> <ul> <li>frequency, \\(f\\) or capacitance, \\(C\\) increases </li> <li>load current, \\(I_L\\) decreases</li> </ul> <p>Warning</p> <p>The constant-current assumption holds only if \\(V_r &lt;&lt; V_S\\) , if larger ripple, you need to use exponential decay equations. </p>"},{"location":"ETL1023%20Analogue%20Electronic/Rectifier/#derivation-of-filter-circuit-full-wave","title":"Derivation of filter circuit (Full-wave)","text":"<p>The key differences between half-wave and full-wave peak rectifiers with capacitor filtering is that:</p> <ul> <li> <p>Half-Wave: Uses only one half of the AC cycle, resulting in a ripple frequency (\\(f\\)) equal to the input AC frequency (e.g., 50 Hz)</p> </li> <li> <p>Full-Wave: Uses both halves of the AC cycle, doubling the ripple frequency (e.g., 100 Hz for 50 Hz input)</p> </li> </ul> <p>Note</p> <ul> <li>Half-Wave Output: Larger gaps between recharge pulses, deeper ripple.</li> <li>Full-Wave Output: More frequent recharging, smaller ripple amplitude.</li> </ul> <p>With full-wave peak rectifier, decaying period is approximately reduced by half, so discharge time is \\(\\frac{T}{2}\\): $$ V_r = \\frac{V_ST}{2CR} = \\frac{V_S}{2fCR}  $$ where, \\(f\\) is the original AC frequency from the source. But the effective ripple frequency is \\(2f\\) . </p> <p>The discharge period (\\(T\\)) is halved, since the capacitor is recharged twice as often:</p> <p>Extra Info</p> <p>Full-wave rectifiers require more diodes but offer better performance, as full-wave rectifier inherently produce less ripple voltage for the same \\(C\\) , \\(R\\) and input frequency because the capacitor discharges for a shorter time. </p>"},{"location":"ETL1023%20Instrumentation/Chapter1/","title":"Introduction","text":""},{"location":"ETL1023%20Instrumentation/Chapter1/#measurement-and-detection","title":"Measurement and Detection","text":"<ul> <li> <p>Measurement is a system that measures physical parameters that can be converted into recordable or comprehensible form of information. </p> </li> <li> <p>Measurement applies to that span in ranges (for example: water level, pressure, temperature, etc.)</p> </li> <li> <p>Detection is a system that detects physical paramters in discrete (two-level) forms (for example: temperature switches, object presence which will give output of True or False, Hot or Cold, etc.)</p> </li> </ul>"},{"location":"ETL1023%20Instrumentation/Chapter1/#instruments","title":"Instruments","text":"<ul> <li> <p>Transducer is a device that converts one type of energy to another type for various purposes (measurement or information transfer)</p> </li> <li> <p>Transducers has different types such as mechanical, electrical, optical, magnetic, etc.</p> </li> <li> <p>Sensors are a specialized transducer that converts a physical parameter (eg. temperature, light, etc.) into usually an electrical signal for measurement.</p> </li> <li> <p>There are different types of sensors, such as motion detectors, magnetic, laser, motion, infrared, airflow, etc.</p> </li> <li> <p>Sensors are transducers, but not all tranducers are sensors (loudspeaker converts electromagnetic energy to mechanical vibration, but it does not measure something, hence it is not a sensor) </p> </li> </ul> <p>Warning</p> <p>Only transducers that are used for measurement qualify as sensors</p>"},{"location":"ETL1023%20Instrumentation/Chapter1/#instrumentation","title":"Instrumentation","text":"<ul> <li>Instrumentation system is a collection engineering system that is used to measure, detect, record, display/indicate and control process parameters that occur in a manufacturing or processing applications. </li> </ul> <p>For Your Information</p> <p>Key components of instrumentation system:</p> <ul> <li> <p>Sensors/Transducers: Convert physical parameters into measurable signals (for example: thermocouples, pressure sensors)</p> </li> <li> <p>Signal Conditioners: Amplify or filter raw signals into clean, standardized form suitable for further processing (for example: analog-to-digital converters)</p> </li> <li> <p>Controllers: Process data and send control commands (for example: PLCs, PID controllers)</p> </li> <li> <p>Actuators: Execute control actions (for example: valves, motors)</p> </li> <li> <p>Human-Machine Interface (HMI): Display data and allow user input</p> </li> </ul>"},{"location":"ETL1023%20Instrumentation/Chapter1/#control","title":"Control","text":"<ul> <li> <p>Automatic Control System is important for hardware automation. </p> </li> <li> <p>A typical mechatronic system that uses the theory of hardware automation looks like:</p> </li> </ul> <p>Raw signal suffer from:</p> <ul> <li> <p>Low amplitude (e.g., microvolts from a thermocouple)</p> </li> <li> <p>Noise/interference (e.g., electromagnetic interference in industrial environments)</p> </li> <li> <p>Non-linearity (e.g., resistance-temperature curves in RTDs)</p> </li> <li> <p>Impedance mismatch (e.g., high-output impedance of piezoelectric sensors)</p> </li> </ul>"},{"location":"ETL1023%20Instrumentation/Chapter2/","title":"Instrument Types and Performance Characteristics","text":""},{"location":"ETL1023%20Instrumentation/Chapter2/#active-and-passive-instruments","title":"Active and passive instruments","text":"Passive Instruments Active Instruments Output produced entirely by the quantity being measured (eg. fluid pressure) Quantity being measured modulates the magnitude of an external power source to produce the output (eg. changes in resistance of strain gauge modulates external voltage) Do not require an external power source to generate output Rely on external power for their operation (usually in electrical form) Passive pressure gauge measures fluid pressure by converting it directly into mechanical movement of a pointer (energy moving pointer comes entirely from pressure change in fluid) Float-type petrol tank level indicator has a float that moves with petrol level and linked to a potentiometer arm which devides an external voltage producing output signal proportional to fuel level (energy from external source &amp; float modulates it)"},{"location":"ETL1023%20Instrumentation/Chapter2/#null-type-and-deflection-type","title":"Null-Type and Deflection-Type","text":"<ul> <li> <p>Deflection-Type Instruments: The measured quantity causes a physical displacement (deflection) of a pointer or sensor which is directly proportional to the input.</p> </li> <li> <p>Null-Type Instruments: The measured quantity is balanced by a known reference force/input until equilibrium (Null Point) is achieved, hence no net deflection occurs at measurement.</p> </li> <li> <p>Pressure gauge is an example of deflection-type instrument (value being measured is displayed in terms of movement of pointer)</p> </li> <li> <p>Dead-weight gauge is an example of null-type instrument: </p> </li> </ul> <p> Basically, the fluid pressure is applied to the base of the piston enclosed in a cylinder. Pressure then creates an upward force <code>F = P x A, where P is pressure, A is piston Area</code> . Calibrated weights are then added to the top of the piston until the donward force balances the upward fluid force. At equilibrium, the piston returns to the reference mark (null point). The formula of <code>P = mg/A</code> is then used to calculate the true output. </p> <ul> <li>Below is a complete comparison between both Null-type and Deflection-type instruments:</li> </ul> Null-Type Deflection-Type Relies on precisely calibrated weights or reference forces Displays measurements instantly via pointer deflection No friction/hysteresis errors (equilibrium at null point) User-friendly (no iterative adjustments needed) Independent of linearity issues (no need for sensor/output linearity) Fast measurements Negligible error sources &amp; very high accuracy Spring/Mechanical Non-Linearity: Requires precise calibration of springs and sensors Slower and less convenient (requires manual weight adjustment) Friction/Wear: Continuous movement introduces errors over time"},{"location":"ETL1023%20Instrumentation/Chapter2/#analogue-and-digital-instruments","title":"Analogue and Digital Instruments","text":"<ul> <li> <p>Digital Instruments: Output signals are discrete numerical values (binary). For example, digital multimeters &amp; smart sensors with embedded processors.</p> </li> <li> <p>Advantages of using a Digital Instrument are:  </p> </li> <li> Direct compatibility  </li> <li> Faster processing  </li> <li> Higher precision (data immediately readable by computers, so eliminates conversion delays)  </li> <li> <p> No quantization error as no analogue to digital converter is used</p> </li> <li> <p>Resolution of a Digital Instrument depends on the sensor itself.</p> </li> <li> <p>Analogue Instruments: Output signals are continuous (voltage, current, or pointer displacement). For example, analog pressure gauges &amp; thermocouples.</p> </li> <li> <p>Must be interfaced to microcomputers by an Analogue-to-Digital (A/D) Converter, which converts continuous signals into discrete digital values for computer processing.</p> </li> <li> <p>Problems of using an Analogue Instrument are:  </p> </li> <li> A/D conversion is not instantaneous; delays can impact real-time control of fast processes  </li> <li> Quantization Error: Digital approximation may lose subtle signal variations</li> </ul>"},{"location":"ETL1023%20Instrumentation/Chapter2/#static-characteristics","title":"Static Characteristics","text":"<ul> <li> <p>Room thermometer is used only for low-accuracy application (Displays 20\u00b0C with a possible error of \u00b10.5\u00b0C (true temperature between 19.5\u201320.5\u00b0C))</p> </li> <li> <p>Human comfort is unaffected by such tiny deviations and there are no critical consequences if the reading is slightly off. Hence, for non-critical applications, lower accuracy instrument (and lower-cost) are already sufficient. </p> </li> <li> <p>However, in critical applications,  a 0.5\u00b0C variation could drastically alter reaction rates or product outcomes. </p> </li> <li> <p>For instance, Chemical processes are often highly sensitive to temperature changes (in pharmaceutical production, a 0.5\u00b0C shift might ruin a batch), hence requiring a high-precision instruments with innacuracies &lt;&lt; 0.5\u00b0C. </p> </li> </ul>"},{"location":"ETL1023%20Instrumentation/Chapter2/#accuracy-and-inaccuracy","title":"Accuracy and Inaccuracy","text":""},{"location":"ETL1023%20Instrumentation/Chapter3/","title":"Measurement Uncertainty","text":"<p>hello test</p>"}]}